## Exercise: Torture-Testing the Chatbot’s Message Payload Builder

### Scenario

You’re working on the web chat widget for the architecture we discussed. Before any REST call goes out to the Conversation Orchestrator, the frontend builds a message payload.
Some nasty production bugs have appeared:
- Random duplicate messages are received.
- Very long or weird Unicode inputs sometimes crash the backend.
- Compliance says some messages are being sent without consent attached.
- Backend team claims: “The frontend is violating the contract.”

Your mission: use property-based testing to shake this payload builder until the bugs fall out.

Refer `property_testing` directory under demos. The example code is TypeScript code which uses `jest` as the test engine along with `fast-check` for property-based testing.

### Business Rules / Invariants

The team gives you the following rules (this is your spec for properties):
1. Conversation linkage
	- conversationId must be non-empty and must come from state.conversationId.
	- userId must be non-empty and must come from state.userId.
2. Consent
	- If state.consentGiven === false, no message must be sent.
		- In this exercise: buildMessagePayload should throw or return an error (pick one and stick to it).
3. Text handling
	- Inputs that are all whitespace or empty are invalid (same behavior as no consent).
	- Text must be sanitized so that < and > never appear in the final text (basic XSS guard).
	- The final text length must be at most MAX_TEXT_LENGTH characters.
		- If the raw text is longer, it should be truncated and must end with "…"  (one ellipsis character).
4. Length field correctness
	- payload.length must equal the number of Unicode code points in payload.text
	  (not bytes, and not just string.length if your language separates surrogate pairs).
5. Identifiers & retry
	- messageId must be a UUID v4 (syntactically).
	- If retryOf is provided:
		- payload.retryOf === retryOf.
		- payload.messageId !== retryOf (retries are new messages, not reusing the same ID).
6. Locale & channel
	- payload.locale === state.locale.
	- payload.channel is always "web".


### A Sample List of Properties

We’ll test these properties against buildMessagePayload(rawText, state, retryOf?).

#### P1 – Conversation & user IDs are propagated

For any valid state and non-empty, non-whitespace rawText,
payload.conversationId === state.conversationId and
payload.userId === state.userId, both non-empty.

#### P2 – Locale & channel are correct

For any valid state and non-empty, non-whitespace rawText,
payload.locale === state.locale and payload.channel === "web".

#### P3 – Text is sanitized & length-bounded

For any valid state and non-empty, non-whitespace rawText,
the returned payload.text contains no < or > and its code-point
length is ≤ MAX_TEXT_LENGTH.

#### P4 – Length field matches actual code points

For any valid state and non-empty, non-whitespace rawText,
payload.length === numberOfCodePoints(payload.text).

#### P5 – Long text gets truncated with ellipsis

For any valid state and long rawText (code-point length > MAX_TEXT_LENGTH),
payload.text ends with "…" and its code-point length is exactly MAX_TEXT_LENGTH.

#### P6 – Consent is required

For any state with consentGiven === false and any rawText,
buildMessagePayload throws an error.

#### P7 – Empty or whitespace-only text is rejected

For any state with consent given and rawText that is empty or only whitespace,
buildMessagePayload throws an error.

#### P8 – Retry semantics

For any valid state, non-empty text, and any retry ID,
payload.retryOf === retryOf (when provided) and
payload.messageId !== retryOf.

#### P9 – Message ID is a UUID v4

For any valid state and non-empty text,
payload.messageId matches a UUID v4 regex.