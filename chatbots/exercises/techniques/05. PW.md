## Pairwise Testing

For the following exercises:

1. Apply Pairwise testing to come with combinations that cover all pairs.
2. Remember that pairwise is not a replacement for:
   - Higher-strength combinations (3-way, 4-way),
   - Or more domain-specific scenario testing


### Exercise 1 – Intent & Channel Combinations

#### Context

You want to test intent recognition and routing across channels and languages. Full combinatorial testing is too big, so you’re introducing pairwise testing.

#### Parameters

| Parameter           | Values                                  |
|---------------------|-----------------------------------------|
| Channel             | Voice, Web Chat                         |
| Language            | German (DE), English (EN), French (FR)  |
| Customer Type       | New, Existing                           |
| Query Category      | Order Tracking, Returns, FAQ            |
| Noise Level (voice) | Quiet, Noisy                            |


(For web chat, “Noise Level” can be treated as “N/A”. It can be paired and then replaced as a logical factor.)


### Exercise 2 (Constraints) - Order Tracking API Integration

#### Scenario

You are testing the **Order Tracking API integration** used by Parloa’s AI agent.

The agent calls a backend `/trackOrder` API to answer questions like:

> “Where is my order 1234?”  
> “Has my insurance claim been processed?”  

The same API is used **across channels** (voice IVR and web chat) and **regions** (Germany, France, US), and it talks to **different backend systems** (legacy OMS, new OMS, partner systems).

Your goal is to design a **pairwise test set** that:

1. **Covers all pairs of input values** (where allowed), and  
2. Respects **realistic constraints** between variables (some combinations must be forbidden).

The focus of the exercise is **not** to get every domain detail perfect, but to:
- See how **pairwise testing reduces the number of combinations**, and  
- Learn how to **encode constraints** based on inter-relationships between variables.

#### Parameters (Input Variables)

You will design tests for the following **request context** sent to `/trackOrder`:

1. **Channel**
   - `Voice_IVR`
   - `Web_Chat`

2. **Region**
   - `DE` (Germany)
   - `FR` (France)
   - `US` (United States)

3. **Customer_Type**
   - `Retail`
   - `Business`

4. **Authentication_Method**
   - `Phone_PIN` (phone number + PIN)
   - `Password_Login`
   - `Magic_Link`

5. **Order_Type**
   - `Physical_Product`
   - `Digital_Service`
   - `Subscription`

6. **Order_Status_Expected_in_Backend**
   - `PLACED`
   - `SHIPPED`
   - `DELIVERED`
   - `CANCELLED`

7. **Backend_System**
   - `Legacy_OMS`
   - `New_OMS_v2`
   - `Partner_System`

8. **Data_Freshness_Mode**
   - `Realtime_Query`
   - `Cached_Response`

9. **Priority_Flag**
   - `Normal`
   - `Express`

10. **Traffic_Load_Profile**
    - `Normal_Load`
    - `Peak_Load`

These 10 parameters × their values give you a large **Cartesian product** (full combination space).

#### Inter-Relationships & Constraints

To make this realistic and interesting for pairwise testing, **not all combinations are valid**. You must **respect the following constraints** when designing your test set:

1. **Channel vs Authentication**
   - `Voice_IVR` **cannot** use `Magic_Link`.
   - `Web_Chat` **typically does not use** `Phone_PIN` (treat this as **invalid** for this exercise).
   - So:
     - `Voice_IVR` → allowed auth methods: `Phone_PIN`, `Password_Login`
     - `Web_Chat` → allowed auth methods: `Password_Login`, `Magic_Link`

2. **Region vs Backend_System**
   - `Partner_System` is **only available** in region `US`.
   - `Legacy_OMS` is **not used** in `FR` (France has fully migrated).
   - So:
     - Region = `DE` → Backend: `Legacy_OMS`, `New_OMS_v2`
     - Region = `FR` → Backend: `New_OMS_v2` only
     - Region = `US` → Backend: `Legacy_OMS`, `New_OMS_v2`, `Partner_System`

3. **Order_Type vs Backend_System**
   - `Subscription` orders are **never stored** in `Legacy_OMS` (only `New_OMS_v2`).
   - `Partner_System` handles **only** `Physical_Product`.
   - So:
     - If `Order_Type = Subscription` → Backend must be `New_OMS_v2`
     - If `Backend_System = Partner_System` → `Order_Type` must be `Physical_Product`

4. **Order_Type vs Priority_Flag**
   - `Express` is meaningful **only for** `Physical_Product`.
   - For `Digital_Service` and `Subscription`, priority is always `Normal`.
   - So:
     - If `Priority_Flag = Express` → `Order_Type` must be `Physical_Product`
     - If `Order_Type` ∈ {`Digital_Service`, `Subscription`} → `Priority_Flag` must be `Normal`

5. **Order_Status_Expected_in_Backend vs Data_Freshness_Mode**
   - `Realtime_Query` must be used when we want to verify **recent shipment updates** (`SHIPPED` or just-`DELIVERED`).
   - `Cached_Response` is **not allowed** when checking `CANCELLED` status (regulatory requirement: must always confirm live).
   - So:
     - If `Order_Status_Expected_in_Backend` ∈ {`SHIPPED`, `DELIVERED`} → both `Realtime_Query` and `Cached_Response` allowed
     - If `Order_Status_Expected_in_Backend = PLACED` → both allowed
     - If `Order_Status_Expected_in_Backend = CANCELLED` → `Data_Freshness_Mode` must be `Realtime_Query`

6. **Traffic_Load_Profile vs Backend_System**
   - Under `Peak_Load`, `Legacy_OMS` may enforce **stricter rate limiting**; you want to ensure those combos appear in your pairwise set.
   - For this exercise, treat all combinations with `Traffic_Load_Profile` as valid — but be mindful of coverage (e.g., you do want some `(Legacy_OMS, Peak_Load)` pairs to appear).


#### Analysis of Test Cases
Check for **contradictions**:
   - Are any values now **unreachable** (e.g., a value that cannot appear in any valid combination)?
   - If yes, decide whether:
     - You misunderstood the constraint, or  
     - The model needs adjustment.

Count how many **valid pairwise test cases** you ended up with.

Compare:
   - `Naive full combinations` (from Step 1) vs.  
   - `Number of pairwise tests` (from Step 3).

Discuss:
   - Are there any **high-risk triples** you might want to add on top of pairwise coverage (e.g., combinations of `Region`, `Backend_System`, and `Order_Type`)?

